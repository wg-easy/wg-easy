import { deflateSync as zlibDeflateSync } from 'node:zlib';
import { parseCidr } from 'cidr-tools';
import { stringifyIp } from 'ip-bigint';
import type { ClientType } from '#db/repositories/client/types';
import type { InterfaceType } from '#db/repositories/interface/types';
import type { UserConfigType } from '#db/repositories/userConfig/types';
import type { HooksType } from '#db/repositories/hooks/types';

type Options = {
  enableIpv6?: boolean;
};

const wgExecutable = WG_ENV.WG_EXECUTABLE;

export const wg = {
  generateServerPeer: (
    client: Omit<ClientType, 'createdAt' | 'updatedAt'>,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const allowedIps = [
      `${client.ipv4Address}/32`,
      ...(enableIpv6 ? [`${client.ipv6Address}/128`] : []),
      ...(client.serverAllowedIps ?? []),
    ];

    const extraLines = [];
    if (client.serverEndpoint) {
      extraLines.push(`Endpoint = ${client.serverEndpoint}`);
    }

    return `# Client: ${client.name} (${client.id})
[Peer]
PublicKey = ${client.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${allowedIps.join(', ')}${extraLines.length ? `\n${extraLines.join('\n')}` : ''}`;
  },

  generateServerInterface: (
    wgInterface: InterfaceType,
    hooks: HooksType,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const cidr4 = parseCidr(wgInterface.ipv4Cidr);
    const cidr6 = parseCidr(wgInterface.ipv6Cidr);
    const ipv4Addr = stringifyIp({ number: cidr4.start + 1n, version: 4 });
    const ipv6Addr = stringifyIp({ number: cidr6.start + 1n, version: 6 });

    const address =
      `${ipv4Addr}/${cidr4.prefix}` +
      (enableIpv6 ? `, ${ipv6Addr}/${cidr6.prefix}` : '');

    let awgLines: string[] = [];

    if (wgExecutable === 'awg') {
      const parameters = {
        Jc: wgInterface.jC,
        Jmin: wgInterface.jMin,
        Jmax: wgInterface.jMax,
        S1: wgInterface.s1,
        S2: wgInterface.s2,
        S3: wgInterface.s3,
        S4: wgInterface.s4,
        I1: wgInterface.i1,
        I2: wgInterface.i2,
        I3: wgInterface.i3,
        I4: wgInterface.i4,
        I5: wgInterface.i5,
        H1: wgInterface.h1,
        H2: wgInterface.h2,
        H3: wgInterface.h3,
        H4: wgInterface.h4,
      } as const;

      awgLines = Object.entries(parameters)
        .filter(([_, value]) => !!value)
        .map(([key, value]) => `${key} = ${value}`);
    }

    const extraLines = [...awgLines].filter((v) => v !== null);

    return `# Note: Do not edit this file directly.
# Your changes will be overwritten!

# Server
[Interface]
PrivateKey = ${wgInterface.privateKey}
Address = ${address}
ListenPort = ${wgInterface.port}
MTU = ${wgInterface.mtu}
${extraLines.length ? `${extraLines.join('\n')}\n` : ''}
PreUp = ${iptablesTemplate(hooks.preUp, wgInterface)}
PostUp = ${iptablesTemplate(hooks.postUp, wgInterface)}
PreDown = ${iptablesTemplate(hooks.preDown, wgInterface)}
PostDown = ${iptablesTemplate(hooks.postDown, wgInterface)}`;
  },

  generateClientConfig: (
    wgInterface: InterfaceType,
    userConfig: UserConfigType,
    client: ClientType,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const address =
      `${client.ipv4Address}/32` +
      (enableIpv6 ? `, ${client.ipv6Address}/128` : '');

    const hookLines = [
      client.preUp ? `PreUp = ${client.preUp}` : null,
      client.postUp ? `PostUp = ${client.postUp}` : null,
      client.preDown ? `PreDown = ${client.preDown}` : null,
      client.postDown ? `PostDown = ${client.postDown}` : null,
    ];

    const dnsServers = client.dns ?? userConfig.defaultDns;
    const dnsLine =
      dnsServers.length > 0 ? `DNS = ${dnsServers.join(', ')}` : null;

    let awgLines: string[] = [];

    if (wgExecutable === 'awg') {
      const parameters = {
        Jc: client.jC,
        Jmin: client.jMin,
        Jmax: client.jMax,
        S1: wgInterface.s1,
        S2: wgInterface.s2,
        S3: wgInterface.s3,
        S4: wgInterface.s4,
        I1: client.i1,
        I2: client.i2,
        I3: client.i3,
        I4: client.i4,
        I5: client.i5,
        H1: wgInterface.h1,
        H2: wgInterface.h2,
        H3: wgInterface.h3,
        H4: wgInterface.h4,
      } as const;

      awgLines = Object.entries(parameters)
        .filter(([_, value]) => !!value)
        .map(([key, value]) => `${key} = ${value}`);
    }

    const extraLines = [dnsLine, ...hookLines, ...awgLines].filter(
      (v) => v !== null
    );

    return `[Interface]
PrivateKey = ${client.privateKey}
Address = ${address}
MTU = ${client.mtu}
${extraLines.length ? `${extraLines.join('\n')}\n` : ''}
[Peer]
PublicKey = ${wgInterface.publicKey}
PresharedKey = ${client.preSharedKey}
AllowedIPs = ${(client.allowedIps ?? userConfig.defaultAllowedIps).join(', ')}
PersistentKeepalive = ${client.persistentKeepalive}
Endpoint = ${userConfig.host}:${userConfig.port}`;
  },

  generateAmneziaVPNClientConfig: (
    wgInterface: InterfaceType,
    userConfig: UserConfigType,
    client: ClientType,
    configText: string,
    options: Options = {}
  ) => {
    const { enableIpv6 = true } = options;

    const address =
      `${client.ipv4Address}/32` +
      (enableIpv6 ? `, ${client.ipv6Address}/128` : '');

    // ip6 DNS servers are not supported by AmneziaVPN app
    const [dns1 = '', dns2 = ''] = (client.dns ?? userConfig.defaultDns ?? []).filter(
      (value) => /^\d{1,3}(?:\.\d{1,3}){3}$/.test(value)
    );

    let awgExtras: Record<string, string> = {};
    let containerType = 'wireguard';

    if (wgExecutable === 'awg') {
      containerType = 'awg';
      // S3, S4, i1, i2, i3, i4, i5 are not supported by AmneziaVPN app for now
      const awgParams = {
        Jc: client.jC,
        Jmin: client.jMin,
        Jmax: client.jMax,
        S1: wgInterface.s1,
        S2: wgInterface.s2,
        // S3: wgInterface.s3,
        // S4: wgInterface.s4,
        // i1: client.i1,
        // i2: client.i2,
        // i3: client.i3,
        // i4: client.i4,
        // i5: client.i5,
        H1: wgInterface.h1,
        H2: wgInterface.h2,
        H3: wgInterface.h3,
        H4: wgInterface.h4,
      } as const;

      awgExtras = Object.fromEntries(
        Object.entries(awgParams)
          .filter(
            ([_, value]) => value !== null && value !== undefined && value !== ''
          )
          .map(([key, value]) => [key, `${value}`])
      );
    }

    const lastConfigObj = {
      ...awgExtras,
      allowed_ips: client.allowedIps ?? userConfig.defaultAllowedIps ?? [],
      client_ip: address,
      client_priv_key: client.privateKey,
      config: configText,
      hostName: userConfig.host,
      mtu: `${client.mtu}`,
      persistent_keep_alive: `${client.persistentKeepalive}`,
      port: +userConfig.port,
      psk_key: client.preSharedKey,
      server_pub_key: wgInterface.publicKey,
    };

    return {
      containers: [
        {
          [containerType]: {
            isThirdPartyConfig: true,
            last_config: JSON.stringify(lastConfigObj),
            port: `${userConfig.port}`,
            transport_proto: 'udp',
          },
          container: `amnezia-${containerType}`,
        },
      ],
      defaultContainer: `amnezia-${containerType}`,
      description: client.name,
      dns1: dns1,
      dns2: dns2,
      hostName: `${userConfig.host}`,
    };
  },

  buildAmneziaQrPack: (amneziaConfigJSON: string) => {
    // Observed working QR wrapper:
    // [0..3]  magic/version (0x07C00100)
    // [4..7]  zlib_len + 4
    // [8..11] uncompressed_len
    // [12..]  zlib(deflate) bytes (starts with 78 DA typically)
    const plain = Buffer.from(amneziaConfigJSON, 'utf8');
    const z = zlibDeflateSync(plain);

    const MAGIC = 0x07c00100;
    const header = Buffer.allocUnsafe(12);
    header.writeUInt32BE(MAGIC, 0);
    header.writeUInt32BE(z.length + 4, 4);
    header.writeUInt32BE(plain.length, 8);

    const packed = Buffer.concat([header, z]);

    return packed.toString('base64url');
  },

  generatePrivateKey: () => {
    return exec(`${wgExecutable} genkey`);
  },

  getPublicKey: (privateKey: string) => {
    return exec(`echo ${privateKey} | ${wgExecutable} pubkey`, {
      log: `echo ***hidden*** | ${wgExecutable} pubkey`,
    });
  },

  generatePreSharedKey: () => {
    return exec(`${wgExecutable} genpsk`);
  },

  up: (infName: string) => {
    return exec(`${wgExecutable}-quick up ${infName}`);
  },

  down: (infName: string) => {
    return exec(`${wgExecutable}-quick down ${infName}`);
  },

  restart: (infName: string) => {
    return exec(
      `${wgExecutable}-quick down ${infName}; ${wgExecutable}-quick up ${infName}`
    );
  },

  sync: (infName: string) => {
    return exec(
      `${wgExecutable} syncconf ${infName} <(${wgExecutable}-quick strip ${infName})`
    );
  },

  dump: async (infName: string) => {
    const rawDump = await exec(`${wgExecutable} show ${infName} dump`, {
      log: false,
    });

    type wgDumpLine = [
      string,
      string,
      string,
      string,
      string,
      string,
      string,
      string,
    ];

    return rawDump
      .trim()
      .split('\n')
      .slice(1)
      .map((line) => {
        const splitLines = line.split('\t');
        const [
          publicKey,
          preSharedKey,
          endpoint,
          allowedIps,
          latestHandshakeAt,
          transferRx,
          transferTx,
          persistentKeepalive,
        ] = splitLines as wgDumpLine;

        return {
          publicKey,
          preSharedKey,
          endpoint: endpoint === '(none)' ? null : endpoint,
          allowedIps,
          latestHandshakeAt:
            latestHandshakeAt === '0'
              ? null
              : new Date(Number.parseInt(`${latestHandshakeAt}000`)),
          transferRx: Number.parseInt(transferRx),
          transferTx: Number.parseInt(transferTx),
          persistentKeepalive: persistentKeepalive,
        };
      });
  },
};
